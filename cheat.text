    

database := client.Database("user_go")
collection := database.Collectuion("user")

cursor , err := collection.Find(ctx, bson.M{})
                
                
                var users []bson.M
                if err = cursor.All(ctx, &users); err != nil {
                    log.Fatal(err)
                }

                for _, user := range users {
                    fmt.Println(user)
                }


defer cursor.Close()
for cursor.Next(ctx) {
    var episode bson.M
    if err = cursor.Decode(&episode); err != nil {
        log.Fat
    }
    fmt.Println(episode)
}



var podcast bson.M
if err := collection.FindOne(ctx, bson.M{}).Decode(&podcast); err != nil {
    fmt.fat
}


opts := options.Find()
opts.SetSort(bson.D{{"duration", -1}})
sortCursor, err := episodeCollection.Find(ctx, bson.D{
    {"duration", bson.D {
        {"$gt", 24}.
    }}, 
}, opts)

var episodeSorted []bson.M
if err = sortCursor.All(ctx, &episodesSorted); err != nil{
    fmt.Fat
}
